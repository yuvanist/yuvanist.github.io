[{"categories":null,"content":"Yet to. ","date":"2022-04-16","objectID":"/random/placeholder/:0:0","tags":null,"title":"Placeholder","uri":"/random/placeholder/"},{"categories":null,"content":"Okay, It has to be said first. Django is one of the prettiest framework you could work with. It offeres everthing under the hood, but as Uncle Ben used to say, With great power there must also come great responsibility Not using things properly or the right way could cause lot of issues. So let‚Äôs go ahead and see some Django queries and how it performs on different conditions. All the Django Queries discussed below are applied on the Benchmark table which has no Index. Here is the structure of it. class Benchmark(models.Model): knowledge_begin_date = models.DateTimeField(null=False) knowledge_end_date = models.DateTimeField(null=True) client_id = models.IntegerField(null=False) databook_id = models.UUIDField(null=False) datasheet_id = models.UUIDField(null=False) data = JSONField(null=True, encoder=DjangoJSONEncoder) Incase, if you wanted to play around the table, you can clone the Django App here I have inserted 2 Million records into the DB table before firing the queries. You can downlad the table here. To insert more rows you can use the script from the git repo mentioned above. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:0:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"1. Difference between only, defer, values and values_list Let‚Äôs understand this four things with a single objective query. We have to get all the Unique databook_ids from our table. That‚Äôs it. That‚Äôs all we have to do. Using .only .only() in Django helps you to take only the selected columns from your Model. Consider a fat model with tons of columns, will be a huge overhead to fetch entire object instead of what you need. benchmark_objects = Benchmark.objects.only('databook_id') unique_databook_ids = set() for each_object in benchmark_objects: unique_databook_ids.add(each_object.databook_id) try: print(benchmark_objects[0].data) except: print('Not able to access data') We took all the object but only with the ‚Äúdatabook_id‚Äù column. This is far better than fetching entire object and iterating over it for ‚Äúdatabook_id‚Äù. Now let‚Äôs look close at the ‚Äútry-and-except‚Äù block. Here I was trying to access the column ‚Äúdata‚Äù which I didn‚Äôt fetch. If you have thought Django would throw Exception for doing this, don‚Äôt worry. you are not alone. I also thought the same at first. But interestingly what happens is One more query will be fired and the data column will be fetched from the table. So there won‚Äôt be any Exception. weird, right? Now coming to the time part, It took 23.72 Seconds in my machine to run this block. Costly. I know. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:1:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"Using .defer() Similar to .only() but instead of taking only that column, it fetches everything apart from what specified in .defer(). benchmark_objects = Benchmark.objects.defer('data') unique_databook_ids = set() for each_object in benchmark_objects: unique_databook_ids.add(each_object.databook_id) try: print(benchmark_objects[0].data) except: print('Not able to access data') Nothing fancy here, same as above, take object without data column which is a JSON field and iterate over it for databook_id. Again, look closely on the ‚Äútry-and-except‚Äù block statement, if you had thought atleast here Django would throw Exception. Sorry Arnab GIFfrom Sorry GIFs Django will fire one more query and fetch data column. This block took whopping 41 Seconds to execute. which is understandable, considering the fact it is fetching all other columns apart from data. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:1:1","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"using .values() If you check .only() and .defer(), you can see that the return type is Object. That‚Äôs why we were accessing it as object.column_name. .values() will return a dictionary instead of a table object. It also allows to select only the set of columns we need to fetch from the table. benchmark_objects = list(Benchmark.objects.values('databook_id')) unique_databook_ids = set() for each_object in benchmark_objects: unique_databook_ids.add(each_object['databook_id']) try: print(benchmark_objects[0]['data']) except: print('Exception: Data is not accessible here') A list of dictionaries will be stored in benchmark_objects and we are iterating over the list to fetch databook_id This block took 10.5 Seconds to execute. which is much better than the previous two. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:1:2","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"using .values_list(flat=True) Cool method. just returns the ‚Äúdatabook_id‚Äù as a flat list. Removing the flat=True would give list of tuple. unique_databook_ids = set( Benchmark.objects.values_list(\"databook_id\", flat=True) ) It executed in 6.72 Seconds. Okay, Okay, I hear you. This is also slow. But did you see something, which is common in all the four blocks above? We took all the objects from the table and added it to set. What if table does that thing instead of us, what would be the performance improvement then? unique_databook_ids = set( Benchmark.objects.values_list(\"databook_id\", flat=True).distinct() ) Just added .distinct() to the query. So the table does the unique filtering. Interestingly, it took only 0.8 Seconds to execute the block. If you have read till now, Thank you and I‚Äôm jealous of you. I would never read any blogs fully. You have nice attention span! Coming back, Remember how we were doing this same operation in the span of 40 seconds or 30 seconds. Now we did the same thing under 1 second. Things to Note: Take only what you need from the table. Don‚Äôt be greedy. Do it in table if you can, if there is no way then use Python vannilla function. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:1:3","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"2. Don‚Äôt bring Knife to Gun fight. Suppose you have to write a block of code which exectues only when there is particular entry is available in table, we can obviously do this in multiple ways. Like, Filtering out all the entries with our condition and applying len() function on it. Filter and do .count() on the query, which returns the number of entries which match our condition. As a wise person, you followed second option remembering what we discussed before ie, Do it in table if you can. db_ds_objects = Benchmark.objects.filter( databook_id=\"61722a62-fe71-44df-86a5-477bcdfbd91c\" ).count() if db_ds_objects \u003e 0: print(\"Yes, one object with this condition exist\") It took 0.3 Seconds execute this block. Not bad right? But wait. Here count is redundant part, we really wanted to know if there exist only one instance where our condition satisfies. That‚Äôs where .exist() method helps. db_ds_objects = Benchmark.objects.filter( databook_id=\"61722a62-fe71-44df-86a5-477bcdfbd91c\" ).exists() if db_ds_objects: print(\"Yes, this object exist\") Does the same thing as the previous block at the expense of 0.03 Seconds. That‚Äôs whopping 100% or 1000% percent reduction in runtime. I know I‚Äôm bad at math üòï You may ask ‚Äúwith the modern Machines I have, why should I even care about this bro?‚Äù. Thing is once the data grows the time difference would increase exponentially. Things to Note: It‚Äôs not only about doing it in table, also doing it in best and right possible way. Read Documentation. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:2:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"3. Call Q() when in trouble. Let‚Äôs say I ask you to give the count of the objects which satisifes the following condition. (databook_id='A' OR datasheet_id='B') AND (NOT the records which has databook_id='A' and datasheet_id='B') databook_condition_objs = Benchmark.objects.filter(databook_id=\"A\") datasheet_condition_objs = Benchmark.objects.filter(datasheet_id=\"B\") combined_objects_before_check = [] for each_object in databook_condition_objs: combined_objects_before_check.append(each_object) for each_object in datasheet_condition_objs: combined_objects_before_check.append(each_object) combined_objects_after_check = [] for each_object in combined_objects_before_check: if not (each_object.databook_id == \"A\" and each_object.datasheet_id == \"B\"): combined_objects_after_check.append(each_object) print(len(combined_objects_after_check)) Double query and filter: we can do two queries seperately, iterate through the objects and filter for the NOT condition. But this is super expensive and very inefficient. Performance can be found even in the darkest of times, when one only remembers to read the documentation. - Not Dumbledore. That‚Äôs when Q() comes to the rescue. What it does is, it allows us to do complex queries at ease. Q() expression can be coupled with filter() function as well. \u0026, |, ~ symbols uses for AND, OR, NOT respectively. databook_condition = Q(databook_id=\"A\") datasheet_condition = Q(datasheet_id=\"B\") both_condition = Q(databook_id=\"A\") \u0026 Q( datasheet_id=\"B\" ) combined_objects_after_check = Benchmark.objects.filter( (databook_condition | datasheet_condition) \u0026 ~both_condition ).count() print(combined_objects_after_check) What did we get from the Q()? Better Performance. Better Code readability Some Happiness. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:3:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"4. What The F(). Now, let‚Äôs say you have to update ‚Äúknowledge_end_date‚Äù of all the rows which has databook_id = ‚ÄòA‚Äô. And you have to update it as ‚Äúknowlege_begin_date‚Äù + 12 days Let me give a example: Before Update: knowledge_begin_date knowledge_end_date databook_id ‚Ä¶ 2022-05-13 NULL A ‚Ä¶ 2021-01-01 NULL B ‚Ä¶ 2022-04-05 NULL A ‚Ä¶ After Update: knowledge_begin_date knowledge_end_date databook_id ‚Ä¶ 2022-05-13 2022-05-25 A ‚Ä¶ 2021-01-01 NULL B ‚Ä¶ 2022-04-05 2022-04-17 A ‚Ä¶ Bruhhh? You really read this long. Damn your attention span. One thing that would come to mind is to fetch all the objects which has databook_id=‚ÄòA‚Äô, iterate over them, update the knowledge_end_date and calling .save() method on the object. Below is the implementation of it. objects = Benchmark.objects.filter(datasheet_id=\"A\") for each_object in objects: each_object.knowledge_end_date = ( each_object.knowledge_begin_date + timedelta(days=10) ) each_object.save() This triggers N+1 queries to update N objects. yeah yeah, I hear you, we can do bulk_update() but what If I tell you there is a better way. Benchmark.objects.filter( datasheet_id=\"A\", ).update(knowledge_end_date=F(\"knowledge_begin_date\") + timedelta(days=10)) This code does the same thing but better. What happens here is F() expression will do the modification within the table without fetching it. Note that, we can only add two things same type. Date + Date or Int + Int and so on. If you try to add Int with Date or String. F() expression will raise exception. Things to Note: Again, Make the Database do the hardwork instead of Python F() reduces number of queries and avoids race condition problem, which occurs in the case of iterate and save. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:4:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"5. Iterate, Iterate, Iterate ‚Ä¶ Suppose your table grown enormously large. You got into a situation where you need to fetch almost 90% of the data from the table. Next thing, you fire a single query with that condition and blow up your memory. databook_id = set() benchmark_objects = Benchmark.objects.all().values(\"databook_id\") for obj in benchmark_objects: databook_ids.add(obj[\"databook_id\"]) Cool, Now that we have blown up our memory with the above query. Let‚Äôs ‚ÄúIterate‚Äù. Iterator is something which gives you only a one instant object at any point of time. You cannot revisit the object you have seen before. Django supports .iterate() which opens a database connection once and instead of fetching all things at one go, you fetch the objects chunk by chunk. you consume the first chunk of objects and then you move to the next chunk. Yes, we are increasing the number of queries here for the advantage of doing things with minimal memory. databook_ids = set() benchmark_objects = ( Benchmark.objects.all().values(\"databook_id\").iterator(chunk_size=2000) ) for obj in benchmark_objects: databook_ids.add(obj[\"databook_id\"]) Let‚Äôs say there are 5420 Objects in your table, 3 Queries will be fired by the above implementation. chunk_size parmeter helps us to configure, how many objects we need to pick for a query. Things to Note: .iterate() increases the number of queries you will make, but reduces memory drastically. If the roundtrip (time takes to connect to remote database, fetch data, and to return it to you.) is high, consider increasing the chunk_size. ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:5:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"6. index good. scan bad. There is no better magic in database than Indexes. It‚Äôs the true comuter science marvel. And the easiest place to increase your application performance exponentially. Suppose if you have index like this, indexes = [ models.Index( fields=[ \"client_id\", \"-knowledge_end_date\", ] ), models.Index(fields=[\"client_id\", \"databook_id\", \"datasheet_id\"]), ] Let‚Äôs see which Queries will do Index Scan and which Queries won‚Äôt. .filter(client_id='1') # Index Scan .filter(client_id='1', databook_id='A') # Index Scan .filter(databook_id='A') # Nopee, Sorry. .filter(datasheet_id='B') # Nopee, Sorry. .filter(client_id='1', databook_id='A',datasheet_id='B') # Index Scan .filter(client_id='1', datasheet_id='B') # Nope, Sorry. Things to Note: Try to se conditions in the filter as same order as the Index. Read https://use-the-index-luke.com/. There is no better site on the Internet which explains Indexes like this. That‚Äôs it folks. Thanks for reading till the end! Next time! The Office Bow GIFfrom The Office GIFs ","date":"2022-04-16","objectID":"/tech/the-one-with-better-django-queries/:6:0","tags":["django","query","python","performance","scaling"],"title":"The One With Better Django Queries","uri":"/tech/the-one-with-better-django-queries/"},{"categories":null,"content":"Oops! Sorry dude, I‚Äôm yet to complete this. Will upload soon! :) ","date":"2022-04-15","objectID":"/traveldump/the-one-where-i-went-to-manali/:0:0","tags":null,"title":"The One Where I went to Manali","uri":"/traveldump/the-one-where-i-went-to-manali/"}]